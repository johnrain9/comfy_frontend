<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Comfy Queue</title>
  <style>
    :root {
      --bg: #111418;
      --panel: #1a1f26;
      --line: #2c3440;
      --text: #d7dde7;
      --muted: #8f9aac;
      --ok: #2ecc71;
      --bad: #ff5b5b;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: "Segoe UI", sans-serif; background: linear-gradient(160deg, #12151b, #0e1116 60%); color: var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; }
    .bar, .panel { border: 1px solid var(--line); border-radius: 10px; background: var(--panel); }
    .bar { display: flex; gap: 14px; align-items: center; padding: 12px 14px; margin-bottom: 14px; flex-wrap: wrap; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
    .ok { background: var(--ok); }
    .bad { background: var(--bad); }
    .panel { padding: 14px; margin-bottom: 14px; }
    label { display: block; margin: 8px 0 4px; color: var(--muted); font-size: 13px; }
    input, textarea, select, button { width: 100%; border: 1px solid var(--line); border-radius: 8px; background: #11161d; color: var(--text); padding: 8px; }
    textarea { min-height: 74px; }
    button { cursor: pointer; background: #1f2732; }
    .btn { width: auto; padding: 8px 12px; }
    .row { display: grid; gap: 10px; }
    .row-2 { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    .table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid var(--line); padding: 8px; text-align: left; vertical-align: top; font-size: 13px; }
    .badge { display: inline-block; border-radius: 999px; padding: 2px 8px; font-size: 11px; }
    .s-pending { background: #3a3f4b; }
    .s-running { background: #234766; }
    .s-succeeded { background: #22462f; }
    .s-failed { background: #5a2d2d; }
    .s-canceled { background: #5a4b2d; }
    .actions button { width: auto; margin-right: 6px; }
    details { margin: 8px 0; }
    pre { white-space: pre-wrap; background: #0d1117; padding: 10px; border-radius: 8px; border: 1px solid var(--line); max-height: 260px; overflow: auto; }
    .inline { display: flex; gap: 8px; align-items: center; }
    .input-with-btn { display: flex; gap: 8px; align-items: center; }
    .input-with-btn input { flex: 1; }
    .browse-btn { width: auto; white-space: nowrap; }
    .hint { color: var(--muted); font-size: 12px; }
    .submit-actions { display: flex; gap: 8px; align-items: center; }
    .submit-actions .btn { width: auto; }
    .tabs { display: flex; gap: 8px; margin-bottom: 8px; }
    .tab-btn { width: auto; padding: 8px 12px; border-radius: 999px; }
    .tab-btn.active { background: #2a3b52; border-color: #4f6787; }
    .hidden { display: none !important; }
    .prompt-list { display: grid; gap: 8px; }
    .prompt-card { border: 1px solid var(--line); border-radius: 8px; background: #121820; padding: 8px; }
    .prompt-meta { color: var(--muted); font-size: 12px; margin-top: 4px; }
    .drop-zone {
      border: 1px dashed #4a5a70;
      border-radius: 8px;
      padding: 10px;
      margin-top: 8px;
      color: var(--muted);
      background: #10161f;
      text-align: center;
      font-size: 12px;
    }
    .drop-zone.active {
      border-color: #6f8fb7;
      background: #132033;
      color: #d5e5ff;
    }
    @media (max-width: 780px) { .row-2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="bar">
      <select id="settingsPresetSelect" style="width:auto; min-width:220px;">
        <option value="">Settings Preset: (none)</option>
      </select>
      <input id="settingsPresetName" placeholder="Settings preset name" style="width:auto; min-width:220px;" />
      <button id="saveSettingsPresetBtn" class="btn">Save Settings</button>
      <div id="comfyStatus"><span class="dot bad"></span>ComfyUI: unknown</div>
      <div id="workerStatus">Worker: unknown</div>
      <div id="queueCounts">pending=0 running=0</div>
      <button id="pauseBtn" class="btn">Pause</button>
      <button id="resumeBtn" class="btn">Resume</button>
      <button id="reloadWorkflowsBtn" class="btn">Reload Workflows</button>
      <button id="reloadLorasBtn" class="btn">Reload LoRAs</button>
    </div>

    <div class="panel">
      <h3>Submit Job</h3>
      <div class="tabs">
        <button id="tabBatch" type="button" class="tab-btn active">Batch</button>
        <button id="tabSingle" type="button" class="tab-btn">Single I2V</button>
        <button id="tabUpscale" type="button" class="tab-btn">Upscale</button>
        <button id="tabUpscaleImages" type="button" class="tab-btn">Upscale Images</button>
      </div>
      <div class="row">
        <div>
          <label>Workflow</label>
          <select id="workflowSelect"></select>
        </div>

        <div class="row-2">
          <div>
            <label>Job Name (optional)</label>
            <input id="jobName" placeholder="e.g. hero-cam / lora-1.2" />
          </div>
        </div>

        <div class="row-2">
          <div>
            <label>Resolution Preset</label>
            <select id="resolutionPreset"></select>
          </div>
          <div>
            <label>Orientation</label>
            <div class="inline" style="padding-top:8px;">
              <input id="flipOrientation" type="checkbox" style="width:auto;" />
              <span>Flip orientation (swap width/height)</span>
            </div>
          </div>
        </div>
        <div>
          <div class="inline" style="padding-top:2px;">
            <input id="moveProcessed" type="checkbox" style="width:auto;" />
            <span>Move processed source files to <code>_processed</code> after successful job</span>
          </div>
        </div>

        <div id="batchInputSection">
          <label>Input Directory</label>
          <div class="input-with-btn">
            <input id="inputDir" list="inputDirHistory" placeholder="/home/cobra/ComfyUI/input/my_batch" />
            <button id="inputBrowseBtn" type="button" class="btn browse-btn">Browse...</button>
          </div>
          <div id="upscaleImagesDropZone" class="drop-zone hidden">Drop one or more images here for Upscale Images mode</div>
          <div class="inline" id="upscaleImagesActions" style="margin-top:6px;">
            <button id="clearUpscaleDropBtn" type="button" class="btn hidden" style="width:auto;">Clear dropped images</button>
          </div>
          <div id="upscaleImagesThumbs" class="row-2 hidden"></div>
          <datalist id="inputDirHistory"></datalist>
          <div class="hint">Accepts Linux absolute paths and pasted Windows/\\wsl.localhost paths.</div>
          <div id="defaultInputDirNotice" class="hint"></div>
        </div>

        <div id="singleInputSection" class="hidden">
          <label>Input Image</label>
          <div class="input-with-btn">
            <input id="inputImage" placeholder="/home/cobra/ComfyUI/input/example.png" />
            <button id="inputImageBrowseBtn" type="button" class="btn browse-btn">Browse...</button>
          </div>
          <div id="singleDropZone" class="drop-zone">Drop one image file here to fill the path</div>
          <div class="hint">Select exactly one image for single I2V job submission.</div>
        </div>

        <div id="promptPresetSection" class="row-2">
          <div>
            <label>Saved Prompts</label>
            <select id="promptPresetSelect">
              <option value="">(none)</option>
            </select>
          </div>
          <div>
            <label>Preset Name</label>
            <div class="input-with-btn">
              <input id="promptPresetName" placeholder="e.g. dragon_orbit_v1" />
              <button id="savePromptPresetBtn" type="button" class="btn browse-btn">Save Prompt</button>
            </div>
          </div>
        </div>

        <div id="paramFields"></div>
        <div class="submit-actions">
          <button id="submitBtn">Submit</button>
          <button id="resetSavedBtn" type="button" class="btn">Reset Saved Options</button>
        </div>
      </div>
      <div id="submitMsg"></div>
    </div>

    <div class="panel">
      <div class="inline" style="justify-content: space-between; align-items: center;">
        <h3 style="margin:0;">Queue</h3>
        <button id="clearQueueBtn" type="button" class="btn" style="width:auto;">Clear Queue</button>
      </div>
      <table class="table" id="jobsTable">
        <thead>
          <tr>
            <th>ID</th><th>Name</th><th>Workflow</th><th>Input Dir</th><th>Status</th><th>Created</th><th>Elapsed</th><th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

<script>
let workflows = [];
let workflowMap = {};
let loraChoices = [];
let upscaleModelChoices = [];
let resolutionPresets = [];
let recentInputDirs = [];
let promptPresets = [];
let settingsPresets = [];
let lastJobsSig = '';
let lastHealthSig = '';
let refreshJobsBusy = false;
let refreshHealthBusy = false;
let currentWorkflowName = '';
let activeTab = 'batch';
let defaultBatchInputDir = '';
let defaultBatchInputExists = true;
let droppedUpscaleInputDir = '';
let droppedUpscaleUploading = false;

function applyUpscaleDroppedStateUI() {
  const input = document.getElementById('inputDir');
  const browse = document.getElementById('inputBrowseBtn');
  const usingDropped = activeTab === 'upscale_images' && !!droppedUpscaleInputDir;
  if (input) {
    input.disabled = usingDropped;
    if (usingDropped) {
      input.placeholder = 'Using dropped images batch (input dir ignored)';
      if (!input.value) input.value = '(using dropped images batch)';
    } else {
      if (input.value === '(using dropped images batch)') input.value = '';
      input.placeholder = '/home/cobra/ComfyUI/input/my_batch';
    }
  }
  if (browse) {
    browse.disabled = usingDropped;
  }
}

const WAN_POSITIVE_TEMPLATE = '(at 0 second: )(at 3 second: )(at 7 second: )';
const UI_STATE_KEY = 'video_queue_ui_state_v1';
const UI_STATE_VERSION = 1;
const LEGACY_DEFAULT_INPUT_DIR = '/home/cobra/ComfyUI/input';

function defaultUiState() {
  return {
    version: UI_STATE_VERSION,
    global: {
      workflow_name: '',
      resolution_preset: '',
      flip_orientation: false,
      move_processed: false,
      input_dir: '',
      single_image: '',
      job_name: '',
      active_tab: 'batch'
    },
    workflow_params: {}
  };
}

let uiState = defaultUiState();

function storageAvailable() {
  try {
    if (!window.localStorage) return false;
    const key = '__vq_test__';
    window.localStorage.setItem(key, '1');
    window.localStorage.removeItem(key);
    return true;
  } catch {
    return false;
  }
}

function clampNumber(value, min, max) {
  let out = value;
  if (min !== null && min !== undefined && out < Number(min)) out = Number(min);
  if (max !== null && max !== undefined && out > Number(max)) out = Number(max);
  return out;
}

function coerceStoredParam(value, paramDef) {
  if (!paramDef) return null;
  const type = String(paramDef.type || '');

  if (type === 'bool') {
    if (typeof value === 'string') {
      const lower = value.trim().toLowerCase();
      if (['false', '0', 'off', 'no', 'n', ''].includes(lower)) return false;
      if (['true', '1', 'on', 'yes', 'y'].includes(lower)) return true;
    }
    return !!value;
  }
  if (type === 'int') {
    const n = parseInt(String(value ?? ''), 10);
    if (!Number.isFinite(n)) return null;
    return clampNumber(n, paramDef.min, paramDef.max);
  }
  if (type === 'float') {
    const n = parseFloat(String(value ?? ''));
    if (!Number.isFinite(n)) return null;
    return clampNumber(n, paramDef.min, paramDef.max);
  }
  return value === null || value === undefined ? '' : String(value);
}

function loadUiState() {
  if (!storageAvailable()) {
    uiState = defaultUiState();
    return;
  }
  try {
    const raw = window.localStorage.getItem(UI_STATE_KEY);
    if (!raw) {
      uiState = defaultUiState();
      return;
    }
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') {
      uiState = defaultUiState();
      return;
    }

    const next = defaultUiState();
    if (parsed.version === UI_STATE_VERSION) {
      if (parsed.global && typeof parsed.global === 'object') {
        next.global.workflow_name = typeof parsed.global.workflow_name === 'string' ? parsed.global.workflow_name : '';
        next.global.resolution_preset = typeof parsed.global.resolution_preset === 'string' ? parsed.global.resolution_preset : '';
        next.global.flip_orientation = !!parsed.global.flip_orientation;
        next.global.move_processed = !!parsed.global.move_processed;
        next.global.input_dir = typeof parsed.global.input_dir === 'string' ? parsed.global.input_dir : '';
        if (next.global.input_dir.trim() === LEGACY_DEFAULT_INPUT_DIR) {
          next.global.input_dir = '';
        }
        next.global.single_image = typeof parsed.global.single_image === 'string' ? parsed.global.single_image : '';
        next.global.job_name = typeof parsed.global.job_name === 'string' ? parsed.global.job_name : '';
        next.global.active_tab = (parsed.global.active_tab === 'single' || parsed.global.active_tab === 'upscale' || parsed.global.active_tab === 'upscale_images')
          ? parsed.global.active_tab
          : 'batch';
      }
      if (parsed.workflow_params && typeof parsed.workflow_params === 'object') {
        for (const [wfName, wfParams] of Object.entries(parsed.workflow_params)) {
          if (!wfName || typeof wfName !== 'string') continue;
          if (!wfParams || typeof wfParams !== 'object') continue;
          next.workflow_params[wfName] = wfParams;
        }
      }
    }
    uiState = next;
  } catch {
    uiState = defaultUiState();
  }
}

function saveUiState() {
  if (!storageAvailable()) return;
  try {
    const payload = JSON.stringify(uiState);
    window.localStorage.setItem(UI_STATE_KEY, payload);
  } catch {
    // Ignore storage errors to keep UI usable.
  }
}

function clearUiState() {
  uiState = defaultUiState();
  if (!storageAvailable()) return;
  try {
    window.localStorage.removeItem(UI_STATE_KEY);
  } catch {
    // Ignore storage errors to keep UI usable.
  }
}

function esc(v){ return String(v ?? ''); }

function prettyJsonText(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return '';
    try {
      return JSON.stringify(JSON.parse(trimmed), null, 2);
    } catch {
      return value;
    }
  }
  try {
    return JSON.stringify(value, null, 2);
  } catch {
    return String(value);
  }
}

function elapsed(created, finished) {
  if (!created) return '-';
  const a = new Date(created).getTime();
  const b = finished ? new Date(finished).getTime() : Date.now();
  const s = Math.max(0, Math.floor((b - a) / 1000));
  const m = Math.floor(s / 60);
  return `${m}m ${s % 60}s`;
}

function decodeFileUri(uri) {
  const raw = String(uri || '').trim();
  if (!raw) return '';
  const lower = raw.toLowerCase();
  if (!lower.startsWith('file://')) return raw;
  let rest = raw.slice(7);
  if (rest.startsWith('localhost/')) rest = rest.slice('localhost'.length);
  try {
    rest = decodeURIComponent(rest);
  } catch {
    // Keep raw path if decoding fails.
  }
  if (/^\/[A-Za-z]:\//.test(rest)) rest = rest.slice(1);
  return rest;
}

function firstDroppedPath(dt) {
  if (!dt) return '';

  const uriList = String(dt.getData('text/uri-list') || '').trim();
  if (uriList) {
    const first = uriList
      .split('\n')
      .map(s => s.trim())
      .find(s => s && !s.startsWith('#'));
    if (first) return decodeFileUri(first);
  }

  const plain = String(dt.getData('text/plain') || '').trim();
  if (plain) return decodeFileUri(plain);

  const files = dt.files;
  if (files && files.length > 0) {
    const f = files[0];
    if (f && typeof f.path === 'string' && f.path.trim()) return f.path.trim();
  }
  return '';
}

async function jfetch(url, opts={}) {
  const r = await fetch(url, opts);
  const text = await r.text();
  let data;
  try { data = JSON.parse(text); } catch { data = text; }
  if (!r.ok) throw new Error(typeof data === 'string' ? data : (data.detail || text));
  return data;
}

function workflowLabel(wf) {
  if (!wf) return '';
  const display = wf.display_name || wf.name;
  const group = wf.group ? `[${wf.group}] ` : '';
  return `${group}${display} - ${wf.description || ''}`.trim();
}

function workflowCategoryForName(name) {
  const text = String(name || '').toLowerCase();
  if (text.includes('upscale-images')) return 'image_upscale';
  if (text.includes('upscale')) return 'video_upscale';
  return 'video_gen';
}

function workflowCategory(wf) {
  if (!wf || typeof wf !== 'object') return 'video_gen';
  const explicit = String(wf.category || '').trim().toLowerCase();
  if (explicit) return explicit;
  return workflowCategoryForName(wf.name || '');
}

function promptModeForTab(tabName) {
  if (tabName === 'upscale') return 'video_upscale';
  if (tabName === 'upscale_images') return 'image_upscale';
  return 'video_gen';
}

function promptModeForActiveTab() {
  return promptModeForTab(activeTab);
}

function allowedWorkflowCategoriesForTab(tabName) {
  const mode = promptModeForTab(tabName);
  if (mode === 'video_upscale') return ['video_upscale'];
  if (mode === 'image_upscale') return ['image_upscale'];
  return ['video_gen'];
}

function getParamElement(name) {
  return document.querySelector(`#paramFields [data-param-name="${name}"]`);
}

function getPromptFieldValues() {
  const pos = getParamElement('positive_prompt') || getParamElement('positive_prompt_stage1');
  const neg = getParamElement('negative_prompt') || getParamElement('negative_prompt_stage1');
  return {
    positive_prompt: pos ? String(pos.value ?? '') : '',
    negative_prompt: neg ? String(neg.value ?? '') : '',
  };
}

function applyPromptFieldValues(values) {
  const pos = getParamElement('positive_prompt') || getParamElement('positive_prompt_stage1');
  const neg = getParamElement('negative_prompt') || getParamElement('negative_prompt_stage1');

  if (pos) {
    pos.value = String(values.positive_prompt ?? '');
    pos.dispatchEvent(new Event('input', { bubbles: true }));
  }
  if (neg) {
    neg.value = String(values.negative_prompt ?? '');
    neg.dispatchEvent(new Event('input', { bubbles: true }));
  }
}

function buildLoraSelect(defaultValue) {
  const sel = document.createElement('select');
  const unique = [];
  const seen = new Set();
  const values = [''].concat(defaultValue || '').concat(loraChoices || []);

  for (const value of values) {
    const name = String(value || '');
    if (seen.has(name)) continue;
    seen.add(name);
    unique.push(name);
  }

  for (const name of unique) {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name || '(empty)';
    sel.appendChild(opt);
  }

  sel.value = String(defaultValue || '');
  return sel;
}

function buildChoicesSelect(defaultValue, choices, emptyLabel='(empty)') {
  const sel = document.createElement('select');
  const unique = [];
  const seen = new Set();
  const values = [''].concat(defaultValue || '').concat(choices || []);
  for (const value of values) {
    const name = String(value || '');
    if (seen.has(name)) continue;
    seen.add(name);
    unique.push(name);
  }
  for (const name of unique) {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name || emptyLabel;
    sel.appendChild(opt);
  }
  sel.value = String(defaultValue || '');
  return sel;
}

function renderResolutionPresets() {
  const sel = document.getElementById('resolutionPreset');
  const existing = sel.value;
  sel.innerHTML = '';
  for (const item of resolutionPresets) {
    const opt = document.createElement('option');
    opt.value = item.id;
    opt.textContent = item.label || item.id;
    sel.appendChild(opt);
  }
  if (existing && [...sel.options].some(o => o.value === existing)) {
    sel.value = existing;
  } else if (sel.options.length > 0) {
    sel.selectedIndex = 0;
  }
}

function updateResolutionControlsForWorkflow() {
  const wf = workflowMap[document.getElementById('workflowSelect').value];
  const supports = !!(wf && wf.supports_resolution);
  const preset = document.getElementById('resolutionPreset');
  const flip = document.getElementById('flipOrientation');
  preset.disabled = !supports;
  flip.disabled = !supports;
}

function renderInputDirHistory() {
  const list = document.getElementById('inputDirHistory');
  list.innerHTML = '';
  for (const path of recentInputDirs) {
    const opt = document.createElement('option');
    opt.value = path;
    list.appendChild(opt);
  }
}

function renderPromptPresets(selectedName='') {
  const sel = document.getElementById('promptPresetSelect');
  const wanted = String(selectedName || sel.value || '');
  sel.innerHTML = '';
  const none = document.createElement('option');
  none.value = '';
  none.textContent = '(none)';
  sel.appendChild(none);

  for (const item of promptPresets) {
    const opt = document.createElement('option');
    opt.value = String(item.name || '');
    const mode = String(item.mode || '').trim();
    opt.textContent = mode ? `${item.name} [${mode}]` : String(item.name || '');
    sel.appendChild(opt);
  }

  if (wanted && [...sel.options].some(o => o.value === wanted)) {
    sel.value = wanted;
  } else {
    sel.value = '';
  }
}

function renderSettingsPresets(selectedName='') {
  const sel = document.getElementById('settingsPresetSelect');
  const wanted = String(selectedName || sel.value || '');
  sel.innerHTML = '';
  const none = document.createElement('option');
  none.value = '';
  none.textContent = 'Settings Preset: (none)';
  sel.appendChild(none);

  for (const item of settingsPresets) {
    const name = String(item.name || '');
    if (!name) continue;
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    sel.appendChild(opt);
  }

  if (wanted && [...sel.options].some(o => o.value === wanted)) {
    sel.value = wanted;
  } else {
    sel.value = '';
  }
}

function workflowHasPromptFields(wf) {
  if (!wf || !wf.parameters || typeof wf.parameters !== 'object') return false;
  return Object.keys(wf.parameters).some(name => /prompt/i.test(name));
}

function workflowsForActiveTab() {
  const allowed = new Set(allowedWorkflowCategoriesForTab(activeTab));
  return workflows.filter((wf) => allowed.has(workflowCategory(wf)));
}

function updatePromptPresetVisibility() {
  const section = document.getElementById('promptPresetSection');
  const wf = workflowMap[document.getElementById('workflowSelect').value];
  const hasPrompts = workflowHasPromptFields(wf);
  section.classList.toggle('hidden', !hasPrompts);
}

function preferredWorkflowsForTab(tabName) {
  if (tabName === 'upscale') return ['upscale-interpolate-only', 'upscale-interpolate'];
  if (tabName === 'upscale_images') return ['upscale-images-i2v'];
  return [];
}

function applyWorkflowFilterForActiveTab(preferredName='') {
  const wfSel = document.getElementById('workflowSelect');
  const previous = wfSel.value || '';
  const filtered = workflowsForActiveTab();
  wfSel.innerHTML = '';
  for (const wf of filtered) {
    const opt = document.createElement('option');
    opt.value = wf.name;
    opt.textContent = workflowLabel(wf);
    wfSel.appendChild(opt);
  }

  const preferred = preferredWorkflowsForTab(activeTab);
  let target = '';
  for (const name of preferred) {
    if (filtered.some((wf) => wf.name === name)) {
      target = name;
      break;
    }
  }
  if (!target && preferredName && filtered.some((wf) => wf.name === preferredName)) {
    target = preferredName;
  }
  if (!target && previous && filtered.some((wf) => wf.name === previous)) {
    target = previous;
  }
  if (!target && filtered.length > 0) {
    target = filtered[0].name;
  }
  if (target) wfSel.value = target;
  return previous !== wfSel.value;
}

function setActiveTab(tabName, persist=true) {
  const next = tabName === 'single'
    ? 'single'
    : (tabName === 'upscale' ? 'upscale' : (tabName === 'upscale_images' ? 'upscale_images' : 'batch'));
  activeTab = next;
  const isSingle = activeTab === 'single';
  const isUpscale = activeTab === 'upscale';
  const isUpscaleImages = activeTab === 'upscale_images';

  document.getElementById('batchInputSection').classList.toggle('hidden', isSingle);
  document.getElementById('singleInputSection').classList.toggle('hidden', !isSingle);
  document.getElementById('upscaleImagesDropZone').classList.toggle('hidden', !isUpscaleImages);
  document.getElementById('upscaleImagesThumbs').classList.toggle('hidden', !isUpscaleImages);
  document.getElementById('tabBatch').classList.toggle('active', activeTab === 'batch');
  document.getElementById('tabSingle').classList.toggle('active', isSingle);
  document.getElementById('tabUpscale').classList.toggle('active', isUpscale);
  document.getElementById('tabUpscaleImages').classList.toggle('active', isUpscaleImages);
  if (applyWorkflowFilterForActiveTab()) {
    currentWorkflowName = document.getElementById('workflowSelect').value || '';
    renderParamFields();
  } else {
    updatePromptPresetVisibility();
  }
  loadPromptPresets().catch(() => {});

  if (persist) {
    uiState.global.active_tab = activeTab;
    saveUiState();
  }
  applyUpscaleDroppedStateUI();
}

function readParamsFromForm() {
  const params = {};
  document.querySelectorAll('#paramFields [data-param-name]').forEach(el => {
    const n = el.dataset.paramName;
    const t = el.dataset.paramType;
    if (!n) return;
    if (t === 'bool') params[n] = !!el.checked;
    else if (t === 'int') params[n] = parseInt(el.value || '0', 10);
    else if (t === 'float') params[n] = parseFloat(el.value || '0');
    else params[n] = String(el.value ?? '');
  });
  return params;
}

function saveCurrentWorkflowParams() {
  const wfName = currentWorkflowName || document.getElementById('workflowSelect').value;
  if (!wfName) return;
  uiState.workflow_params[wfName] = readParamsFromForm();
  saveUiState();
}

function syncGlobalStateFromForm() {
  const workflow = document.getElementById('workflowSelect').value;
  const resolution = document.getElementById('resolutionPreset').value;
  const flip = !!document.getElementById('flipOrientation').checked;
  const moveProcessed = !!document.getElementById('moveProcessed').checked;
  const inputDir = document.getElementById('inputDir').value.trim();
  const inputImage = document.getElementById('inputImage').value.trim();
  const jobName = document.getElementById('jobName').value.trim();

  uiState.global.workflow_name = workflow || '';
  uiState.global.resolution_preset = resolution || '';
  uiState.global.flip_orientation = flip;
  uiState.global.move_processed = moveProcessed;
  uiState.global.input_dir = inputDir;
  uiState.global.single_image = inputImage;
  uiState.global.job_name = jobName;
  uiState.global.active_tab = activeTab;
  saveUiState();
}

function applySavedGlobalState() {
  const resolution = document.getElementById('resolutionPreset');
  const flip = document.getElementById('flipOrientation');
  const moveProcessed = document.getElementById('moveProcessed');
  const input = document.getElementById('inputDir');
  const image = document.getElementById('inputImage');
  const jobName = document.getElementById('jobName');

  const preset = String(uiState.global.resolution_preset || '');
  if (preset && [...resolution.options].some(opt => opt.value === preset)) {
    resolution.value = preset;
  }
  flip.checked = !!uiState.global.flip_orientation;
  moveProcessed.checked = !!uiState.global.move_processed;
  if (uiState.global.input_dir) input.value = uiState.global.input_dir;
  else input.value = defaultBatchInputDir || '';
  if (uiState.global.single_image) image.value = uiState.global.single_image;
  if (uiState.global.job_name) jobName.value = uiState.global.job_name;
  const t = uiState.global.active_tab === 'single'
    ? 'single'
    : (uiState.global.active_tab === 'upscale'
      ? 'upscale'
      : (uiState.global.active_tab === 'upscale_images' ? 'upscale_images' : 'batch'));
  setActiveTab(t, false);
}

function resetSavedOptions() {
  clearUiState();
  const msg = document.getElementById('submitMsg');
  const workflowSelect = document.getElementById('workflowSelect');
  const resolution = document.getElementById('resolutionPreset');
  const input = document.getElementById('inputDir');
  const image = document.getElementById('inputImage');
  const flip = document.getElementById('flipOrientation');
  const moveProcessed = document.getElementById('moveProcessed');
  const jobName = document.getElementById('jobName');

  if (workflowSelect.options.length > 0) workflowSelect.selectedIndex = 0;
  if (resolution.options.length > 0) resolution.selectedIndex = 0;
  input.value = defaultBatchInputDir || '';
  image.value = '';
  flip.checked = false;
  moveProcessed.checked = false;
  jobName.value = '';
  setActiveTab('batch', false);
  currentWorkflowName = workflowSelect.value || '';
  renderParamFields();
  syncGlobalStateFromForm();
  msg.textContent = 'Saved options cleared.';
}

function renderParamFields() {
  const sel = document.getElementById('workflowSelect').value;
  const wf = workflowMap[sel];
  const box = document.getElementById('paramFields');
  box.innerHTML = '';
  if (!wf) return;
  currentWorkflowName = wf.name;
  const savedParams = (uiState.workflow_params && typeof uiState.workflow_params[wf.name] === 'object')
    ? uiState.workflow_params[wf.name]
    : {};
  let upscaleNetHintEl = null;

  function inferModelScale(name) {
    const text = String(name || '').toLowerCase();
    const m = text.match(/(?:^|[^0-9])x(\d+)(?:[^0-9]|$)/);
    if (!m) return null;
    const n = parseFloat(m[1]);
    return Number.isFinite(n) && n > 0 ? n : null;
  }

  function updateUpscaleNetHint() {
    if (!upscaleNetHintEl) return;
    const modelEl = getParamElement('upscale_model_name');
    const postEl = getParamElement('final_scale_factor');
    if (!modelEl || !postEl) {
      upscaleNetHintEl.textContent = '';
      return;
    }
    const modelScale = inferModelScale(modelEl.value);
    const postScale = parseFloat(String(postEl.value || ''));
    if (!Number.isFinite(postScale) || postScale <= 0) {
      upscaleNetHintEl.textContent = 'Net upscale: enter a valid post-AI scale factor.';
      return;
    }
    if (!modelScale) {
      upscaleNetHintEl.textContent = `Net upscale: source * model_scale * ${postScale.toFixed(2)} (model scale unknown from name).`;
      return;
    }
    const net = modelScale * postScale;
    upscaleNetHintEl.textContent = `Net upscale: ${net.toFixed(2)}x = source * ${modelScale.toFixed(0)} * ${postScale.toFixed(2)}.`;
  }

  function makeParamWrap(name, p) {
    const wrap = document.createElement('div');
    const label = document.createElement('label');
    label.textContent = p.label || name;
    wrap.appendChild(label);

    let defaultValue = p.default;
    if ((defaultValue === null || defaultValue === undefined || defaultValue === '') && name === 'positive_prompt' && /^wan-/.test(wf.name || '')) {
      defaultValue = WAN_POSITIVE_TEMPLATE;
    }
    const saved = Object.prototype.hasOwnProperty.call(savedParams, name) ? savedParams[name] : undefined;
    const restored = saved === undefined ? null : coerceStoredParam(saved, p);
    const fieldValue = restored === null ? defaultValue : restored;

    let el;
    if (p.type === 'bool') {
      el = document.createElement('input');
      el.type = 'checkbox';
      el.checked = !!fieldValue;
      el.style.width = 'auto';
      const row = document.createElement('div');
      row.className = 'inline';
      row.appendChild(el);
      const t = document.createElement('span');
      t.textContent = name;
      row.appendChild(t);
      wrap.appendChild(row);
    } else if (p.type === 'text' && /lora/i.test(name)) {
      el = buildLoraSelect(fieldValue);
      wrap.appendChild(el);
    } else if (p.type === 'text' && /upscale.*model|model.*upscale/.test(name)) {
      el = buildChoicesSelect(fieldValue, upscaleModelChoices, '(select model)');
      wrap.appendChild(el);
    } else if (p.type === 'text' && /prompt/i.test(name)) {
      el = document.createElement('textarea');
      el.value = fieldValue ?? '';
      wrap.appendChild(el);
    } else {
      el = document.createElement('input');
      el.type = (p.type === 'int' || p.type === 'float') ? 'number' : 'text';
      if (p.min !== null && p.min !== undefined) el.min = p.min;
      if (p.max !== null && p.max !== undefined) el.max = p.max;
      el.value = fieldValue ?? '';
      wrap.appendChild(el);
    }
    el.dataset.paramName = name;
    el.dataset.paramType = p.type;
    if (name === 'final_scale_factor') {
      upscaleNetHintEl = document.createElement('div');
      upscaleNetHintEl.className = 'hint';
      wrap.appendChild(upscaleNetHintEl);
    }
    const persistParam = () => {
      saveCurrentWorkflowParams();
      updateUpscaleNetHint();
    };
    el.addEventListener('change', persistParam);
    el.addEventListener('input', persistParam);
    return wrap;
  }

  function extraGroupIndex(name) {
    if (name.startsWith('extra_lora3_')) return 3;
    if (name.startsWith('extra_lora2_')) return 2;
    if (name.startsWith('extra_lora_')) return 1;
    return 0;
  }

  function appendExtraHint(container, idx) {
    const hint = document.createElement('div');
    hint.className = 'hint';
    hint.textContent = idx === 1
      ? '0 disables this extra LoRA. Base 4-step lightx2v LoRAs remain enabled.'
      : '0 disables this extra LoRA slot.';
    container.appendChild(hint);
  }

  function stageIndexForPrompt(name) {
    const m = /^positive_prompt_stage(\d+)$/.exec(name) || /^negative_prompt_stage(\d+)$/.exec(name);
    if (!m) return 0;
    const idx = parseInt(m[1], 10);
    return Number.isFinite(idx) && idx > 0 ? idx : 0;
  }

  const extraContainers = {};
  for (const idx of [1, 2, 3]) {
    const details = document.createElement('details');
    details.open = false;
    const summary = document.createElement('summary');
    summary.textContent = `Extra LoRA ${idx}`;
    details.appendChild(summary);
    const body = document.createElement('div');
    body.className = 'row';
    details.appendChild(body);
    extraContainers[idx] = { details, body, used: false };
  }

  const stageContainers = {};
  const recoverContainer = (() => {
    const details = document.createElement('details');
    details.open = false;
    const summary = document.createElement('summary');
    summary.textContent = 'Recover (low-quality inputs)';
    details.appendChild(summary);
    const body = document.createElement('div');
    body.className = 'row-2';
    details.appendChild(body);
    return { details, body, used: false };
  })();

  for (const [name, p] of Object.entries(wf.parameters || {})) {
    const wrap = makeParamWrap(name, p);
    if (name.startsWith('recover_')) {
      recoverContainer.used = true;
      recoverContainer.body.appendChild(wrap);
      continue;
    }
    const idx = extraGroupIndex(name);
    if (idx > 0) {
      extraContainers[idx].used = true;
      extraContainers[idx].body.appendChild(wrap);
      if (name === `extra_lora${idx === 1 ? '' : idx}_strength`) {
        appendExtraHint(extraContainers[idx].body, idx);
      }
      continue;
    }
    const stageIdx = stageIndexForPrompt(name);
    if (stageIdx > 0) {
      if (!stageContainers[stageIdx]) {
        const details = document.createElement('details');
        details.open = true;
        const summary = document.createElement('summary');
        summary.textContent = `Stage ${stageIdx} Prompts`;
        details.appendChild(summary);
        const body = document.createElement('div');
        body.className = 'row';
        details.appendChild(body);
        stageContainers[stageIdx] = { details, body };
      }
      stageContainers[stageIdx].body.appendChild(wrap);
      continue;
    }
    box.appendChild(wrap);
  }

  const stageIndexes = Object.keys(stageContainers).map(Number).sort((a, b) => a - b);
  for (const idx of stageIndexes) {
    box.appendChild(stageContainers[idx].details);
  }

  for (const idx of [1, 2, 3]) {
    if (extraContainers[idx].used) {
      box.appendChild(extraContainers[idx].details);
    }
  }
  if (recoverContainer.used) {
    const hint = document.createElement('div');
    hint.className = 'hint';
    hint.textContent = 'Disabled by default. Enable only for low-quality inputs that need stronger enhancement.';
    recoverContainer.body.appendChild(hint);
    box.appendChild(recoverContainer.details);
  }

  saveCurrentWorkflowParams();
  updateResolutionControlsForWorkflow();
  updatePromptPresetVisibility();
  updateUpscaleNetHint();
}

async function normalizeInputDirField() {
  const input = document.getElementById('inputDir');
  const msg = document.getElementById('submitMsg');
  const raw = input.value.trim();
  if (!raw) return '';

  try {
    const data = await jfetch('/api/input-dirs/normalize', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ path: raw })
    });
    const normalized = data.normalized_path || raw;
    input.value = normalized;
    syncGlobalStateFromForm();
    return normalized;
  } catch (e) {
    msg.textContent = `Path error: ${e.message}`;
    throw e;
  }
}

async function normalizeInputImageField() {
  const input = document.getElementById('inputImage');
  const msg = document.getElementById('submitMsg');
  const raw = input.value.trim();
  if (!raw) return '';

  try {
    const data = await jfetch('/api/input-dirs/normalize', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ path: raw })
    });
    const normalized = data.normalized_path || raw;
    input.value = normalized;
    syncGlobalStateFromForm();
    return normalized;
  } catch (e) {
    msg.textContent = `Path error: ${e.message}`;
    throw e;
  }
}

async function loadLoras() {
  try {
    const data = await jfetch('/api/loras');
    loraChoices = Array.isArray(data) ? data : [];
  } catch {
    loraChoices = [];
  }
}

async function loadUpscaleModels() {
  const common = ['RealESRGAN_x2plus.pth', 'RealESRGAN_x4plus.pth', 'RealESRNet_x4plus.pth'];
  try {
    const data = await jfetch('/api/upscale-models');
    const found = Array.isArray(data) ? data : [];
    upscaleModelChoices = [...new Set([...found, ...common])];
  } catch {
    upscaleModelChoices = [...common];
  }
}

async function loadResolutionPresets() {
  try {
    const data = await jfetch('/api/resolution-presets');
    resolutionPresets = Array.isArray(data.presets) ? data.presets : [];
  } catch {
    resolutionPresets = [];
  }
  renderResolutionPresets();
}

async function loadRecentInputDirs() {
  try {
    const data = await jfetch('/api/input-dirs/recent?limit=20');
    recentInputDirs = Array.isArray(data.paths) ? data.paths : [];
  } catch {
    recentInputDirs = [];
  }
  renderInputDirHistory();
}

async function loadPromptPresets(selectedName='', modeOverride='') {
  const mode = String(modeOverride || promptModeForActiveTab() || '').trim();
  const query = mode ? `?limit=500&mode=${encodeURIComponent(mode)}` : '?limit=500';
  try {
    const data = await jfetch(`/api/prompt-presets${query}`);
    promptPresets = Array.isArray(data.items) ? data.items : [];
  } catch {
    promptPresets = [];
  }
  renderPromptPresets(selectedName);
}

async function loadSettingsPresets(selectedName='') {
  try {
    const data = await jfetch('/api/settings-presets?limit=500');
    settingsPresets = Array.isArray(data.items) ? data.items : [];
  } catch {
    settingsPresets = [];
  }
  renderSettingsPresets(selectedName);
}

function buildSettingsPayloadFromForm() {
  saveCurrentWorkflowParams();
  syncGlobalStateFromForm();
  return {
    workflow_name: document.getElementById('workflowSelect').value || '',
    resolution_preset: document.getElementById('resolutionPreset').value || '',
    flip_orientation: !!document.getElementById('flipOrientation').checked,
    move_processed: !!document.getElementById('moveProcessed').checked,
    input_dir: document.getElementById('inputDir').value || '',
    single_image: document.getElementById('inputImage').value || '',
    job_name: document.getElementById('jobName').value || '',
    active_tab: activeTab,
    prompt_preset_name: document.getElementById('promptPresetSelect').value || '',
    workflow_params: uiState.workflow_params || {},
  };
}

function applySettingsPayload(payload) {
  if (!payload || typeof payload !== 'object') return;

  const wfSel = document.getElementById('workflowSelect');
  const resSel = document.getElementById('resolutionPreset');
  const flip = document.getElementById('flipOrientation');
  const moveProcessed = document.getElementById('moveProcessed');
  const inputDir = document.getElementById('inputDir');
  const inputImage = document.getElementById('inputImage');
  const jobName = document.getElementById('jobName');
  const promptPresetSel = document.getElementById('promptPresetSelect');

  if (payload.workflow_params && typeof payload.workflow_params === 'object') {
    uiState.workflow_params = payload.workflow_params;
  }

  const tab = payload.active_tab === 'single'
    ? 'single'
    : (payload.active_tab === 'upscale'
      ? 'upscale'
      : (payload.active_tab === 'upscale_images' ? 'upscale_images' : 'batch'));
  setActiveTab(tab, false);

  const wfName = String(payload.workflow_name || '');
  if (wfName && workflowMap[wfName] && [...wfSel.options].some(o => o.value === wfName)) {
    wfSel.value = wfName;
  }
  currentWorkflowName = wfSel.value || '';
  renderParamFields();

  const preset = String(payload.resolution_preset || '');
  if (preset && [...resSel.options].some(o => o.value === preset)) {
    resSel.value = preset;
  }
  flip.checked = !!payload.flip_orientation;
  moveProcessed.checked = !!payload.move_processed;
  inputDir.value = String(payload.input_dir || '');
  inputImage.value = String(payload.single_image || '');
  jobName.value = String(payload.job_name || '');

  const promptPresetName = String(payload.prompt_preset_name || '');
  loadPromptPresets(promptPresetName, promptModeForActiveTab()).then(() => {
    if (promptPresetName && [...promptPresetSel.options].some(o => o.value === promptPresetName)) {
      promptPresetSel.value = promptPresetName;
      applySelectedPromptPreset();
    } else if (!promptPresetName) {
      promptPresetSel.value = '';
    }
  }).catch(() => {});

  syncGlobalStateFromForm();
}

function applySelectedSettingsPreset() {
  const sel = document.getElementById('settingsPresetSelect');
  const name = String(sel.value || '').trim();
  if (!name) return;
  const preset = settingsPresets.find(x => String(x.name || '') === name);
  if (!preset || typeof preset.payload !== 'object') return;
  applySettingsPayload(preset.payload);
  document.getElementById('settingsPresetName').value = name;
  document.getElementById('submitMsg').textContent = `Applied settings preset '${name}'.`;
}

async function saveSettingsPresetFromUI() {
  const msg = document.getElementById('submitMsg');
  const btn = document.getElementById('saveSettingsPresetBtn');
  const nameInput = document.getElementById('settingsPresetName');
  const name = String(nameInput.value || '').trim();
  if (!name) {
    msg.textContent = 'Settings preset name is required.';
    return;
  }

  const payload = buildSettingsPayloadFromForm();
  const original = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Saving...';
  try {
    await jfetch('/api/settings-presets', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ name, payload })
    });
    await loadSettingsPresets(name);
    msg.textContent = `Saved settings preset '${name}'.`;
  } catch (e) {
    msg.textContent = `Save settings error: ${e.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = original;
  }
}

function applySelectedPromptPreset() {
  const sel = document.getElementById('promptPresetSelect');
  const name = String(sel.value || '').trim();
  if (!name) return;
  const preset = promptPresets.find(x => String(x.name || '') === name);
  if (!preset) return;
  applyPromptFieldValues({
    positive_prompt: String(preset.positive_prompt || ''),
    negative_prompt: String(preset.negative_prompt || ''),
  });
  saveCurrentWorkflowParams();
  document.getElementById('promptPresetName').value = name;
}

async function savePromptPresetFromUI() {
  const msg = document.getElementById('submitMsg');
  const btn = document.getElementById('savePromptPresetBtn');
  const nameInput = document.getElementById('promptPresetName');
  const name = String(nameInput.value || '').trim();
  if (!name) {
    msg.textContent = 'Preset name is required.';
    return;
  }

  const values = getPromptFieldValues();
  const posField = getParamElement('positive_prompt') || getParamElement('positive_prompt_stage1');
  const negField = getParamElement('negative_prompt') || getParamElement('negative_prompt_stage1');
  if (!posField && !negField) {
    msg.textContent = 'Current workflow has no prompt fields to save.';
    return;
  }

  const original = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Saving...';
  try {
    const mode = promptModeForActiveTab();
    await jfetch('/api/prompt-presets', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        name,
        mode,
        positive_prompt: values.positive_prompt,
        negative_prompt: values.negative_prompt,
      })
    });
    await loadPromptPresets(name, mode);
    msg.textContent = `Saved prompt preset '${name}' [${mode}].`;
  } catch (e) {
    msg.textContent = `Save preset error: ${e.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = original;
  }
}

async function loadDefaultInputDir() {
  const notice = document.getElementById('defaultInputDirNotice');
  notice.textContent = '';
  defaultBatchInputDir = '';
  defaultBatchInputExists = true;
}

async function loadWorkflows(preferredName) {
  workflows = await jfetch('/api/workflows');
  workflowMap = Object.fromEntries(workflows.map(w => [w.name, w]));
  const sel = document.getElementById('workflowSelect');
  const fallback = preferredName || uiState.global.workflow_name || sel.value || '';
  applyWorkflowFilterForActiveTab(fallback);
  currentWorkflowName = sel.value || '';
  renderParamFields();
  applySavedGlobalState();
  syncGlobalStateFromForm();
  lastJobsSig = '';
}

async function reloadWorkflowsFromUI() {
  const msg = document.getElementById('submitMsg');
  const btn = document.getElementById('reloadWorkflowsBtn');
  saveCurrentWorkflowParams();
  syncGlobalStateFromForm();
  const current = document.getElementById('workflowSelect').value;
  const previous = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Reloading...';
  try {
    const data = await jfetch('/api/reload/workflows', { method: 'POST' });
    await loadWorkflows(current);
    msg.textContent = `Reloaded workflows (${data.count})`;
  } catch (e) {
    msg.textContent = `Workflow reload error: ${e.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = previous;
  }
}

async function reloadLorasFromUI() {
  const msg = document.getElementById('submitMsg');
  const btn = document.getElementById('reloadLorasBtn');
  const previous = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Reloading...';
  try {
    const data = await jfetch('/api/reload/loras', { method: 'POST' });
    loraChoices = Array.isArray(data.loras) ? data.loras : [];
    renderParamFields();
    msg.textContent = `Reloaded LoRAs (${data.count})`;
  } catch (e) {
    msg.textContent = `LoRA reload error: ${e.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = previous;
  }
}

async function submitJob() {
  const msg = document.getElementById('submitMsg');
  msg.textContent = '';

  const workflow_name = document.getElementById('workflowSelect').value;
  const wf = workflowMap[workflow_name];
  const supportsResolution = !!(wf && wf.supports_resolution);
  const resolutionPreset = document.getElementById('resolutionPreset').value;
  const flipOrientation = !!document.getElementById('flipOrientation').checked;
  const moveProcessed = !!document.getElementById('moveProcessed').checked;

  const params = readParamsFromForm();
  const rawJobName = document.getElementById('jobName').value.trim();
  const modePrefix = activeTab === 'single'
    ? 'single'
    : (activeTab === 'upscale'
      ? 'upscale'
      : (activeTab === 'upscale_images' ? 'upscale_images' : 'batch'));
  const prefixedJobName = rawJobName
    ? (rawJobName.toLowerCase().startsWith(`${modePrefix} `) ? rawJobName : `${modePrefix} ${rawJobName}`)
    : '';
  uiState.workflow_params[workflow_name] = params;
  syncGlobalStateFromForm();

  let pathPayload = {};
  let endpoint = '/api/jobs';
  if (activeTab === 'single') {
    let input_image;
    try {
      input_image = await normalizeInputImageField();
    } catch {
      return;
    }
    if (!input_image) {
      msg.textContent = 'Single I2V requires one input image.';
      return;
    }
    endpoint = '/api/jobs/single';
    pathPayload = { input_image };
  } else {
    let input_dir = '';
    if (activeTab === 'upscale_images' && droppedUpscaleUploading) {
      msg.textContent = 'Upload in progress. Wait for dropped images to finish uploading.';
      return;
    }
    if (activeTab === 'upscale_images' && droppedUpscaleInputDir) {
      input_dir = droppedUpscaleInputDir;
      document.getElementById('inputDir').value = droppedUpscaleInputDir;
      syncGlobalStateFromForm();
    } else {
      try {
        input_dir = await normalizeInputDirField();
      } catch {
        return;
      }
    }
    pathPayload = { input_dir };
  }

  try {
    const data = await jfetch(endpoint, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        workflow_name,
        job_name: prefixedJobName || null,
        ...pathPayload,
        params,
        resolution_preset: supportsResolution ? resolutionPreset : null,
        flip_orientation: supportsResolution ? flipOrientation : false,
        move_processed: moveProcessed,
        split_by_input: activeTab !== 'single'
      })
    });
    const ids = Array.isArray(data.job_ids) ? data.job_ids : [];
    if (ids.length > 1) {
      msg.textContent = `Queued ${ids.length} jobs (${ids[0]}...${ids[ids.length - 1]})`;
    } else if (ids.length === 1) {
      msg.textContent = `Submitted job ${ids[0]}`;
    } else {
      msg.textContent = `Submitted job ${data.job_id}`;
    }
    lastJobsSig = '';
    await loadRecentInputDirs();
    await refreshJobs();
  } catch (e) {
    msg.textContent = `Error: ${e.message}`;
  }
}

async function browseInputDir() {
  const btn = document.getElementById('inputBrowseBtn');
  const input = document.getElementById('inputDir');
  const msg = document.getElementById('submitMsg');
  const previousLabel = btn.textContent;

  btn.disabled = true;
  btn.textContent = 'Picking...';
  try {
    const current = input.value.trim();
    const data = await jfetch('/api/pick-directory', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ start_dir: current || null })
    });
    input.value = data.path || '';
    if (data.path) {
      msg.textContent = `Selected: ${data.path}`;
      syncGlobalStateFromForm();
    }
  } catch (e) {
    msg.textContent = `Browse error: ${e.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = previousLabel;
  }
}

async function browseInputImage() {
  const btn = document.getElementById('inputImageBrowseBtn');
  const input = document.getElementById('inputImage');
  const msg = document.getElementById('submitMsg');
  const previousLabel = btn.textContent;

  btn.disabled = true;
  btn.textContent = 'Picking...';
  try {
    const current = input.value.trim();
    const data = await jfetch('/api/pick-image', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ start_path: current || null })
    });
    input.value = data.path || '';
    if (data.path) {
      msg.textContent = `Selected image: ${data.path}`;
      syncGlobalStateFromForm();
    }
  } catch (e) {
    msg.textContent = `Image browse error: ${e.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = previousLabel;
  }
}

async function uploadDroppedImage(fileObj, subdir='') {
  const filename = (fileObj && fileObj.name) ? String(fileObj.name) : 'upload.png';
  const headers = {
    'Content-Type': (fileObj && fileObj.type) ? fileObj.type : 'application/octet-stream',
    'X-Filename': filename
  };
  if (subdir) headers['X-Subdir'] = String(subdir);
  return jfetch('/api/upload/input-image', {
    method: 'POST',
    headers,
    body: fileObj
  });
}

function setupSingleDropZone() {
  const zone = document.getElementById('singleDropZone');
  const input = document.getElementById('inputImage');
  const msg = document.getElementById('submitMsg');
  if (!zone || !input) return;

  const activate = () => zone.classList.add('active');
  const deactivate = () => zone.classList.remove('active');

  zone.addEventListener('dragenter', (e) => {
    e.preventDefault();
    activate();
  });
  zone.addEventListener('dragover', (e) => {
    e.preventDefault();
    activate();
  });
  zone.addEventListener('dragleave', () => {
    deactivate();
  });
  zone.addEventListener('drop', (e) => {
    e.preventDefault();
    deactivate();
    const path = firstDroppedPath(e.dataTransfer);
    const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;

    if (path) {
      input.value = path;
      syncGlobalStateFromForm();
      normalizeInputImageField()
        .then(() => {
          msg.textContent = `Selected image: ${input.value}`;
        })
        .catch(() => {});
      return;
    }

    if (!files || files.length === 0) {
      msg.textContent = 'Could not read dropped file. Use Browse or paste full path.';
      return;
    }

    uploadDroppedImage(files[0])
      .then((data) => {
        input.value = String((data && data.path) || '');
        syncGlobalStateFromForm();
        msg.textContent = `Uploaded + selected image: ${input.value}`;
      })
      .catch((err) => {
        msg.textContent = `Drop upload error: ${err.message}`;
      });
  });
}

function setupUpscaleImagesDropZone() {
  const zone = document.getElementById('upscaleImagesDropZone');
  const input = document.getElementById('inputDir');
  const thumbs = document.getElementById('upscaleImagesThumbs');
  const clearBtn = document.getElementById('clearUpscaleDropBtn');
  const msg = document.getElementById('submitMsg');
  if (!zone || !input) return;

  function setClearVisible(visible) {
    if (!clearBtn) return;
    clearBtn.classList.toggle('hidden', !visible);
  }

  function clearDroppedUpscaleState(showMessage = false) {
    droppedUpscaleInputDir = '';
    if (thumbs) {
      thumbs.innerHTML = '';
      thumbs.classList.add('hidden');
    }
    setClearVisible(false);
    applyUpscaleDroppedStateUI();
    if (showMessage) {
      msg.textContent = 'Cleared dropped images for Upscale Images mode.';
    }
  }

  const activate = () => zone.classList.add('active');
  const deactivate = () => zone.classList.remove('active');

  function renderThumbs(files) {
    if (!thumbs) return;
    thumbs.innerHTML = '';
    const list = Array.from(files || []).slice(0, 8);
    if (list.length === 0) {
      thumbs.classList.add('hidden');
      setClearVisible(false);
      return;
    }
    for (const f of list) {
      const card = document.createElement('div');
      card.style.display = 'flex';
      card.style.gap = '8px';
      card.style.alignItems = 'center';
      card.style.padding = '6px';
      card.style.border = '1px solid var(--line)';
      card.style.borderRadius = '8px';
      card.style.background = '#0f141b';
      const img = document.createElement('img');
      img.style.width = '44px';
      img.style.height = '44px';
      img.style.objectFit = 'cover';
      img.style.borderRadius = '6px';
      img.alt = String((f && f.name) || 'image');
      try {
        img.src = URL.createObjectURL(f);
      } catch {
        img.src = '';
      }
      const label = document.createElement('div');
      label.className = 'hint';
      label.textContent = String((f && f.name) || 'image');
      card.appendChild(img);
      card.appendChild(label);
      thumbs.appendChild(card);
    }
    thumbs.classList.remove('hidden');
    setClearVisible(true);
  }

  zone.addEventListener('dragenter', (e) => {
    e.preventDefault();
    activate();
  });
  zone.addEventListener('dragover', (e) => {
    e.preventDefault();
    activate();
  });
  zone.addEventListener('dragleave', () => {
    deactivate();
  });
  zone.addEventListener('drop', async (e) => {
    e.preventDefault();
    deactivate();
    const dt = e.dataTransfer;
    const files = dt && dt.files ? dt.files : null;
    if (!files || files.length === 0) {
      msg.textContent = 'Drop image files to upload for Upscale Images mode.';
      return;
    }

    const allowed = ['.png', '.jpg', '.jpeg', '.webp', '.bmp'];
    const valid = [];
    for (let i = 0; i < files.length; i += 1) {
      const f = files[i];
      const name = String((f && f.name) || '').toLowerCase();
      if (allowed.some(ext => name.endsWith(ext))) valid.push(f);
    }
    if (valid.length === 0) {
      msg.textContent = 'No supported image files found in drop.';
      return;
    }
    renderThumbs(valid);

    const dropToken = `uploads/upscale_images/${Date.now()}`;
    droppedUpscaleUploading = true;
    msg.textContent = `Uploading ${valid.length} image(s)...`;
    try {
      const uploaded = [];
      for (const fileObj of valid) {
        const data = await uploadDroppedImage(fileObj, dropToken);
        uploaded.push(data);
      }
      const dir = String((uploaded[0] && uploaded[0].dir) || '');
      if (!dir) {
        msg.textContent = 'Upload succeeded but could not resolve input directory.';
        return;
      }
      droppedUpscaleInputDir = dir;
      input.value = '';
      applyUpscaleDroppedStateUI();
      syncGlobalStateFromForm();
      msg.textContent = `Uploaded ${uploaded.length} image(s) for Upscale Images mode.`;
    } catch (err) {
      msg.textContent = `Upscale drop upload error: ${err.message}`;
      droppedUpscaleInputDir = '';
      applyUpscaleDroppedStateUI();
      setClearVisible(false);
    } finally {
      droppedUpscaleUploading = false;
    }
  });

  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      clearDroppedUpscaleState(true);
      if (activeTab === 'upscale_images') {
        input.value = '';
        applyUpscaleDroppedStateUI();
        syncGlobalStateFromForm();
      }
    });
  }
}

function statusBadge(status) {
  return `<span class="badge s-${status}">${status}</span>`;
}

async function jobAction(jobId, action, triggerBtn) {
  const msg = document.getElementById('submitMsg');
  const btn = triggerBtn || null;
  const original = btn ? btn.textContent : '';
  if (btn) {
    btn.disabled = true;
    btn.textContent = action === 'cancel' ? 'Canceling...' : 'Retrying...';
  }

  try {
    const data = await jfetch(`/api/jobs/${jobId}/${action}`, { method: 'POST' });
    if (action === 'cancel') {
      const c = data.cancel_summary || {};
      const running = Number(c.running_prompts || 0);
      const canceledPending = Number(c.canceled_pending || 0);
      if (running > 0) {
        msg.textContent = `Cancel requested for job ${jobId}: canceled ${canceledPending} pending prompt(s), waiting for ${running} running prompt(s).`;
      } else {
        msg.textContent = `Canceled job ${jobId}: canceled ${canceledPending} pending prompt(s).`;
      }
    }
    if (action === 'retry') {
      msg.textContent = `Retried job ${jobId}.`;
    }
    lastJobsSig = '';
    lastHealthSig = '';
    await refreshJobs();
    await refreshHealth();
  } catch (e) {
    msg.textContent = `${action} failed for job ${jobId}: ${e.message}`;
  } finally {
    if (btn) {
      btn.disabled = false;
      btn.textContent = original;
    }
  }
}

async function clearQueueFromUI() {
  const msg = document.getElementById('submitMsg');
  const btn = document.getElementById('clearQueueBtn');
  const c1 = window.confirm('Clear entire queue and delete all jobs/prompts?');
  if (!c1) return;
  const c2 = window.confirm('Final confirmation: this will permanently delete the entire queue history. Continue?');
  if (!c2) return;

  const prev = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Clearing...';
  try {
    const out = await jfetch('/api/queue/clear', { method: 'POST' });
    const dj = Number(out.deleted_jobs || 0);
    const dp = Number(out.deleted_prompts || 0);
    msg.textContent = `Queue cleared. Deleted jobs=${dj}, prompts=${dp}.`;
    lastJobsSig = '';
    lastHealthSig = '';
    await refreshJobs();
    await refreshHealth();
  } catch (e) {
    msg.textContent = `Clear queue error: ${e.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = prev;
  }
}

async function loadJobDetail(jobId, detailsEl) {
  const body = detailsEl.querySelector('[data-detail-body]');
  if (!body) return;

  body.innerHTML = 'Loading...';
  try {
    const detail = await jfetch(`/api/jobs/${jobId}`);
    const jobInfo = detail && typeof detail.job === 'object' ? detail.job : {};
    const prompts = Array.isArray(detail.prompts) ? detail.prompts : [];
    body.innerHTML = '';

    const list = document.createElement('div');
    list.className = 'prompt-list';

    for (const p of prompts) {
      const card = document.createElement('div');
      card.className = 'prompt-card';

      const header = document.createElement('div');
      const comfyPromptId = p.prompt_id ? String(p.prompt_id) : '-';
      header.innerHTML = `<strong>Prompt Row ${esc(p.id)}</strong> | ${statusBadge(esc(p.status || 'unknown'))}`;
      card.appendChild(header);

      const meta = document.createElement('div');
      meta.className = 'prompt-meta';
      meta.textContent = `Comfy prompt_id: ${comfyPromptId}`;
      card.appendChild(meta);

      const file = document.createElement('div');
      file.className = 'prompt-meta';
      file.textContent = `Input: ${esc(p.input_file || '-')}`;
      card.appendChild(file);

      if (p.output_paths) {
        const out = document.createElement('div');
        out.className = 'prompt-meta';
        out.textContent = `Outputs: ${esc(p.output_paths)}`;
        card.appendChild(out);
      }
      if (p.error_detail) {
        const err = document.createElement('div');
        err.className = 'prompt-meta';
        err.textContent = `Error: ${esc(p.error_detail)}`;
        card.appendChild(err);
      }

      const payloadDetails = document.createElement('details');
      const payloadSummary = document.createElement('summary');
      payloadSummary.textContent = 'Prompt JSON';
      payloadDetails.appendChild(payloadSummary);
      const payloadPre = document.createElement('pre');
      payloadPre.textContent = prettyJsonText(p.prompt_json);
      payloadDetails.appendChild(payloadPre);
      card.appendChild(payloadDetails);

      list.appendChild(card);
    }

    const summary = document.createElement('div');
    summary.className = 'prompt-meta';
    const jobName = String(jobInfo.job_name || '').trim();
    summary.textContent = `Job ID: ${jobId}${jobName ? ` | Name: ${jobName}` : ''} | Prompt rows: ${prompts.length}`;
    body.appendChild(summary);
    body.appendChild(list);

    const settingsDetails = document.createElement('details');
    const settingsSummary = document.createElement('summary');
    settingsSummary.textContent = 'Run Settings';
    settingsDetails.appendChild(settingsSummary);
    const settingsPre = document.createElement('pre');
    settingsPre.textContent = prettyJsonText(jobInfo.params_json) || '{}';
    settingsDetails.appendChild(settingsPre);
    body.appendChild(settingsDetails);
  } catch (e) {
    body.textContent = `Error loading detail: ${e.message}`;
  }
}

function computeJobsSig(jobs) {
  const compact = jobs.map(j => [j.id, j.job_name, j.status, j.prompt_count, j.created_at, j.finished_at]);
  return JSON.stringify(compact);
}

async function refreshJobs() {
  if (refreshJobsBusy) return;
  refreshJobsBusy = true;
  try {
    const jobs = await jfetch('/api/jobs');
    const sig = computeJobsSig(jobs);
    if (sig === lastJobsSig) return;
    lastJobsSig = sig;

    const tbody = document.querySelector('#jobsTable tbody');
    tbody.innerHTML = '';

    for (const job of jobs) {
      const wf = workflowMap[job.workflow_name];
      const wfLabel = wf ? (wf.display_name || job.workflow_name) : job.workflow_name;
      const jobName = String(job.job_name || '').trim() || '-';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${job.id}</td>
        <td>${esc(jobName)}</td>
        <td>${esc(wfLabel)}</td>
        <td>${esc(job.input_dir)}</td>
        <td>${statusBadge(job.status)}</td>
        <td>${esc(job.created_at || '-')}</td>
        <td>${elapsed(job.created_at, job.finished_at)}</td>
        <td class="actions">
          <button data-cancel="${job.id}">Cancel</button>
          <button data-retry="${job.id}">Retry</button>
        </td>
      `;
      tbody.appendChild(tr);

      const dtr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 8;

      const details = document.createElement('details');
      const sum = document.createElement('summary');
      sum.textContent = `Job ${job.id} Prompts (${job.prompt_count ?? 0})`;
      details.appendChild(sum);

      const detailBody = document.createElement('div');
      detailBody.setAttribute('data-detail-body', '1');
      detailBody.textContent = 'Open to load details.';
      details.appendChild(detailBody);

      let loaded = false;
      details.addEventListener('toggle', () => {
        if (details.open && !loaded) {
          loaded = true;
          loadJobDetail(job.id, details);
        }
      });

      td.appendChild(details);
      dtr.appendChild(td);
      tbody.appendChild(dtr);
    }

    document.querySelectorAll('[data-cancel]').forEach(b => b.onclick = () => jobAction(b.dataset.cancel, 'cancel', b));
    document.querySelectorAll('[data-retry]').forEach(b => b.onclick = () => jobAction(b.dataset.retry, 'retry', b));
  } finally {
    refreshJobsBusy = false;
  }
}

function computeHealthSig(h) {
  return JSON.stringify([h.comfy, h.worker, h.pending, h.running]);
}

async function refreshHealth() {
  if (refreshHealthBusy) return;
  refreshHealthBusy = true;
  try {
    const h = await jfetch('/api/health');
    const sig = computeHealthSig(h);
    if (sig === lastHealthSig) return;
    lastHealthSig = sig;

    document.getElementById('comfyStatus').innerHTML = `<span class="dot ${h.comfy ? 'ok' : 'bad'}"></span>ComfyUI: ${h.comfy ? 'up' : 'down'}`;
    document.getElementById('workerStatus').textContent = `Worker: ${h.worker}`;
    document.getElementById('queueCounts').textContent = `pending=${h.pending} running=${h.running}`;
  } finally {
    refreshHealthBusy = false;
  }
}

document.getElementById('workflowSelect').addEventListener('change', () => {
  saveCurrentWorkflowParams();
  currentWorkflowName = document.getElementById('workflowSelect').value || '';
  renderParamFields();
  syncGlobalStateFromForm();
});
document.getElementById('submitBtn').addEventListener('click', submitJob);
document.getElementById('resetSavedBtn').addEventListener('click', resetSavedOptions);
document.getElementById('inputBrowseBtn').addEventListener('click', browseInputDir);
document.getElementById('inputImageBrowseBtn').addEventListener('click', browseInputImage);
document.getElementById('tabBatch').addEventListener('click', () => {
  setActiveTab('batch');
  syncGlobalStateFromForm();
});
document.getElementById('tabSingle').addEventListener('click', () => {
  setActiveTab('single');
  syncGlobalStateFromForm();
});
document.getElementById('tabUpscale').addEventListener('click', () => {
  setActiveTab('upscale');
  syncGlobalStateFromForm();
});
document.getElementById('tabUpscaleImages').addEventListener('click', () => {
  setActiveTab('upscale_images');
  syncGlobalStateFromForm();
});
document.getElementById('inputDir').addEventListener('input', () => {
  const v = document.getElementById('inputDir').value.trim();
  if (activeTab === 'upscale_images' && droppedUpscaleInputDir && v !== droppedUpscaleInputDir) {
    droppedUpscaleInputDir = '';
    applyUpscaleDroppedStateUI();
  }
  syncGlobalStateFromForm();
});
document.getElementById('inputDir').addEventListener('blur', () => { normalizeInputDirField().catch(() => {}); });
document.getElementById('inputImage').addEventListener('input', syncGlobalStateFromForm);
document.getElementById('inputImage').addEventListener('blur', () => { normalizeInputImageField().catch(() => {}); });
document.getElementById('jobName').addEventListener('input', syncGlobalStateFromForm);
document.getElementById('promptPresetSelect').addEventListener('change', applySelectedPromptPreset);
document.getElementById('savePromptPresetBtn').addEventListener('click', savePromptPresetFromUI);
document.getElementById('settingsPresetSelect').addEventListener('change', applySelectedSettingsPreset);
document.getElementById('saveSettingsPresetBtn').addEventListener('click', saveSettingsPresetFromUI);
document.getElementById('resolutionPreset').addEventListener('change', syncGlobalStateFromForm);
document.getElementById('flipOrientation').addEventListener('change', syncGlobalStateFromForm);
document.getElementById('moveProcessed').addEventListener('change', syncGlobalStateFromForm);
document.getElementById('pauseBtn').addEventListener('click', () => jfetch('/api/queue/pause', {method:'POST'}).then(() => { lastHealthSig = ''; return refreshHealth(); }));
document.getElementById('resumeBtn').addEventListener('click', () => jfetch('/api/queue/resume', {method:'POST'}).then(() => { lastHealthSig = ''; return refreshHealth(); }));
document.getElementById('reloadWorkflowsBtn').addEventListener('click', reloadWorkflowsFromUI);
document.getElementById('reloadLorasBtn').addEventListener('click', reloadLorasFromUI);
document.getElementById('clearQueueBtn').addEventListener('click', clearQueueFromUI);

(async function init() {
  loadUiState();
  await loadLoras();
  await loadUpscaleModels();
  await loadResolutionPresets();
  await loadRecentInputDirs();
  await loadPromptPresets();
  await loadSettingsPresets();
  await loadDefaultInputDir();
  await loadWorkflows();
  setupSingleDropZone();
  setupUpscaleImagesDropZone();
  applyUpscaleDroppedStateUI();
  await refreshHealth();
  await refreshJobs();
  setInterval(refreshHealth, 5000);
  setInterval(refreshJobs, 3000);
})();
</script>
</body>
</html>
